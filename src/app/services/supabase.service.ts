import { Injectable } from "@angular/core";
import { PostgrestResponseFailure } from "@supabase/postgrest-js/src/types";
import {
  AuthChangeEvent,
  AuthError,
  createClient,
  PostgrestError,
  PostgrestSingleResponse,
  Session,
  SupabaseClient,
} from "@supabase/supabase-js";
import { from, map, Observable, switchMap } from "rxjs";
import { environment } from "../../environments/environment";
import { Todo } from "../model/todo";
import { HttpClient, HttpHeaders } from "@angular/common/http";

type SessionType =
  | { data: { session: Session }; error: null }
  | { data: { session: null }; error: AuthError }
  | {
      data: { session: null };
      error: null;
    };

// create table todos (
//   id bigint generated by default as identity primary key,
//   user_id uuid references auth.users not null,
//   name text check (char_length(name) > 3),
//   is_complete boolean default false,
//   inserted_at timestamp with time zone default timezone('utc'::text, now()) not null
// );
// alter table todos enable row level security;
// create policy "Individuals can create todos." on todos for
//     insert with check (auth.uid() = user_id);
// create policy "Individuals can view their own todos. " on todos for
//     select using (auth.uid() = user_id);
// create policy "Individuals can update their own todos." on todos for
//     update using (auth.uid() = user_id);
// create policy "Individuals can delete their own todos." on todos for
//     delete using (auth.uid() = user_id);

@Injectable({
  providedIn: "root",
})
export class SupabaseService {
  private supabaseClient: SupabaseClient;

  constructor(private httpClient: HttpClient) {
    this.supabaseClient = createClient(
      environment.supabaseUrl,
      environment.supabaseAnonKey
    );
  }


  signIn(email: string, password: string): void {
    this.supabaseClient.auth
      .signInWithPassword({ email, password })
      .then(({ error }) => this.handleError(error));
  }

  signOut(): void {
    this.supabaseClient.auth.signOut().catch(console.error);
  }

  authChanges(
    callback: (event: AuthChangeEvent, session: Session | null) => void
  ): void {
    this.supabaseClient.auth.onAuthStateChange(callback);
  }

  async fetchTodos(): Promise<Todo[]> {
    return this.supabaseClient
      .from("todos")
      .select("*")
      .order("id", { ascending: false })
      .then(({ data, error }) => {
        this.handleError(error);
        return (data || []) as unknown as Todo[];
      });
  }

  getTodos(): Observable<Todo[]> {
    return from(
      this.getSession().then((ses) => {
        return ses.data.session?.access_token;
      })
    ).pipe(
      switchMap((authToken) => {
        const options = this.getOptions();
        // const authToken = this.supabaseClient["changedAccessToken"];
        options.headers = options.headers
          .append("apikey", environment.supabaseAnonKey)
          .append("Authorization", `Bearer ${authToken as string}`);
        console.log(options);
        return this.httpClient.get<Todo[]>(
          environment.production
            ? environment.supabaseUrl
            : "" + "/todos?select=*&order=id.desc",
          options
        );
      })
    );
  }  
  networkRestrictions(): void{
    from(
      this.getSession().then((ses) => {
        return ses.data.session?.access_token;
      })
    ).pipe(
      switchMap((authToken) => {
        const options = this.getOptions();
        // const authToken = this.supabaseClient["changedAccessToken"];
        options.headers = options.headers
          .append("apikey", environment.supabaseAnonKey)
          .append("Authorization", `Bearer ${authToken as string}`);
        return this.httpClient.get<Todo[]>(
          environment.production
            ? environment.supabaseUrl
            : "" + "/network-restrictions",
          options
        );
      })
    ).subscribe(res => console.log(res));
  }

  getOptions() {
    return {
      headers: new HttpHeaders()
        .set("Accept", "*/*")
        .append("Content-Type", "application/json"),
      withCredentials: true,
    };
  }

  async addTodo(name: string): Promise<PostgrestSingleResponse<Todo>> {
    return this.getSession().then(({ data }) => {
      const userId = data.session?.user?.id as string;
      return this.supabaseClient
        .from("todos")
        .insert({ name, user_id: userId })
        .single();
    });
  }

  private async getSession(): Promise<SessionType> {
    return this.supabaseClient.auth.getSession();
  }

  async deleteTodo(
    id: string
  ): Promise<PostgrestResponseFailure | PostgrestSingleResponse<null>> {
    return this.supabaseClient
      .from("todos")
      .delete()
      .eq("id", id)
      .then((resp) => {
        this.handleError(resp.error);
        return resp;
      });
  }

  private handleError(error: null | AuthError | PostgrestError): void {
    if (error) {
      alert(error.message);
    }
  }
}
