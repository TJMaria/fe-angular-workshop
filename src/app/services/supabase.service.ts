import { Injectable } from '@angular/core';
import {
  AuthChangeEvent,
  AuthError,
  createClient,
  PostgrestError,
  PostgrestSingleResponse,
  Session,
  SupabaseClient
} from '@supabase/supabase-js';
import { from, map, Observable } from 'rxjs';
import { environment } from '../../environments/environment';
import { Todo } from '../model/todo';

type SessionType = { data: { session: Session }; error: null } | { data: { session: null }; error: AuthError } | {
  data: { session: null };
  error: null
};

/**
 * create table todos (
 *   id bigint generated by default as identity primary key,
 *   user_id uuid references auth.users not null,
 *   name text check (char_length(name) > 3),
 *   is_complete boolean default false,
 *   inserted_at timestamp with time zone default timezone('utc'::text, now()) not null
 * );
 * alter table todos enable row level security;
 * create policy "Individuals can create todos." on todos for
 *     insert with check (auth.uid() = user_id);
 * create policy "Individuals can view their own todos. " on todos for
 *     select using (auth.uid() = user_id);
 * create policy "Individuals can update their own todos." on todos for
 *     update using (auth.uid() = user_id);
 * create policy "Individuals can delete their own todos." on todos for
 *     delete using (auth.uid() = user_id);
 */

@Injectable({
  providedIn: 'root'
})
export class SupabaseService {
  private supabaseClient: SupabaseClient;

  constructor() {
    this.supabaseClient = createClient(environment.supabaseUrl, environment.supabaseAnonKey);
  }

  signIn(email: string, password: string): void {
    this.supabaseClient.auth.signInWithPassword({ email, password }).then(({ error }) => this.handleError(error));
  }

  signOut(): void {
    this.supabaseClient.auth.signOut().catch(console.error);
  }

  authChanges(callback: (event: AuthChangeEvent, session: Session | null) => void): void {
    this.supabaseClient.auth.onAuthStateChange(callback);
  }

  fetchTodos(): Observable<Todo[]> {
    return from(this.supabaseClient.from('todos').select('*').order('id', { ascending: false })).pipe(
      map(({ data, error }) => {
        this.handleError(error);
        return (data || []) as unknown as Todo[];
      })
    );
  }

  async addTodo(name: string): Promise<PostgrestSingleResponse<Todo>> {
    const { data, error } = await this.getSession();
    const userId = data.session?.user?.id as string;
    return this.supabaseClient.from('todos').insert({ name, user_id: userId }).single();
  }

  async getSession(): Promise<SessionType> {
    return this.supabaseClient.auth.getSession();
  }

  async deleteTodo(id: string) {
    const resp = await this.supabaseClient.from('todos').delete().eq('id', id);
    this.handleError(resp.error);
    return resp;
  }

  private handleError(error: null | AuthError | PostgrestError) {
    if (error) {
      alert(error.message);
    }
  }
}
