import { Injectable } from '@angular/core';
import { AuthChangeEvent, AuthError, createClient, Session, SupabaseClient } from '@supabase/supabase-js';
import { environment } from '../../environments/environment';

type SessionType = { data: { session: Session }; error: null } | { data: { session: null }; error: AuthError } | {
  data: { session: null };
  error: null
};

/**
 * create table todos (
 *   id bigint generated by default as identity primary key,
 *   user_id uuid references auth.users not null,
 *   name text check (char_length(name) > 3),
 *   is_complete boolean default false,
 *   inserted_at timestamp with time zone default timezone('utc'::text, now()) not null
 * );
 * alter table todos enable row level security;
 * create policy "Individuals can create todos." on todos for
 *     insert with check (auth.uid() = user_id);
 * create policy "Individuals can view their own todos. " on todos for
 *     select using (auth.uid() = user_id);
 * create policy "Individuals can update their own todos." on todos for
 *     update using (auth.uid() = user_id);
 * create policy "Individuals can delete their own todos." on todos for
 *     delete using (auth.uid() = user_id);
 */

@Injectable({
  providedIn: 'root'
})
export class SupabaseService {
  private supabaseClient: SupabaseClient;
  token: string | undefined;

  constructor() {
    this.supabaseClient = createClient(environment.supabaseUrl, environment.supabaseAnonKey);
    console.log(this.supabaseClient.auth);
  }

  signUp(email: string, password: string) {
    return this.supabaseClient.auth.signUp({ email, password });
  }

  signIn(email: string, password: string) {
    return this.supabaseClient.auth.signInWithPassword({ email, password });
  }

  // signInWithProvider(provider: Provider) {
  //   return this.supabaseClient.auth.sign({ provider })
  // }

  signOut() {
    this.supabaseClient.auth.signOut().catch(console.error);
  }

  authChanges(callback: (event: AuthChangeEvent, session: Session | null) => void) {
    return this.supabaseClient.auth.onAuthStateChange(callback);
  }

  resetPassword(email: string) {
    return this.supabaseClient.auth.resetPasswordForEmail(email);
  }

  handleNewPassword(newPassword: string) {
    return this.supabaseClient.auth.updateUser({
      password: newPassword
    });
  }

  fetchTodos() {
    return this.supabaseClient.from('todos').select('*').order('id', { ascending: false });
  }

  async addTodo(name: string) {
    const { data, error } = await this.getSession();
    const { session } = data;

    const userId = session?.user?.id as string;
    return this.supabaseClient.from('todos').insert({ name, user_id: userId }).single();
  }

  async getSession(): Promise<SessionType> {
    return this.supabaseClient.auth.getSession();
  }

  toggleComplete(id: string, isCompleted: boolean) {
    return this.supabaseClient
               .from('todos')
               .update({ is_complete: !isCompleted })
               .eq('id', id)
               .single();
  }

  deleteTodo(id: string) {
    return this.supabaseClient.from('todos').delete().eq('id', id);
  }
}
